============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-7.1.3, pluggy-1.0.0 -- /home/i/myProject/django_sprint4/django-sprint4-2/venv/bin/python3
django: settings: blogicum.settings (from ini)
rootdir: /home/i/myProject/django_sprint4/django-sprint4-1, configfile: pytest.ini, testpaths: tests/
plugins: django-4.5.2, Faker-12.0.1
collecting ... collected 26 items

tests/test_content.py::TestContent::test_unpublished FAILED              [  3%]
tests/test_content.py::TestContent::test_only_own_pubs_in_category PASSED [  7%]
tests/test_content.py::TestContent::test_only_own_pubs_in_profile FAILED [ 11%]
tests/test_content.py::TestContent::test_unpublished_category FAILED     [ 15%]
tests/test_content.py::TestContent::test_future_posts FAILED             [ 19%]
tests/test_content.py::TestContent::test_pagination FAILED               [ 23%]
tests/test_content.py::TestContent::test_image_visible FAILED            [ 26%]
tests/test_err_pages.py::test_custom_err_handlers PASSED                 [ 30%]
tests/test_users.py::test_custom_err_handlers PASSED                     [ 34%]
tests/test_users.py::test_profile FAILED                                 [ 38%]
tests/test_comment.py::test_comment_created_at PASSED                    [ 42%]
tests/test_comment.py::test_comment FAILED                               [ 46%]
tests/test_comment.py::test_404_on_comment_deleted_post PASSED           [ 50%]
tests/test_post.py::test_post_created_at PASSED                          [ 53%]
tests/test_post.py::test_post FAILED                                     [ 57%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`post` field] <- tests/conftest.py PASSED [ 61%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`author` field] <- tests/conftest.py PASSED [ 65%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`text` field] <- tests/conftest.py PASSED [ 69%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`created_at` field] <- tests/conftest.py PASSED [ 73%]
tests/test_comment.py::test_link_order_in_comment_template PASSED        [ 76%]
tests/test_emails.py::test_gitignore PASSED                              [ 80%]
tests/test_emails.py::test_email_backend_settings PASSED                 [ 84%]
tests/test_err_pages.py::test_csrf_failure_view PASSED                   [ 88%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`image` field] <- tests/conftest.py PASSED [ 92%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`pub_date` field] <- tests/conftest.py PASSED [ 96%]
tests/test_static_pages.py::test_static_pages_as_cbv PASSED              [100%]

=================================== FAILURES ===================================
_________________________ TestContent.test_unpublished _________________________

self = <test_content.ProfilePostContentTester object at 0x7fe5f420d8a0>
client = <django.test.client.Client object at 0x7fe5f4384460>
url = '/profile/gabrielaware/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f4384460>
path = '/profile/gabrielaware/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f4384460>
path = '/profile/gabrielaware/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f4384460>, method = 'GET'
path = '/profile/gabrielaware/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/gabrielaware/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/gabrielaware/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f4384460>
request = {'PATH_INFO': '/profile/gabrielaware/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=byjl8a9yaml63v5sc2x9emkx4ye46lau', 'PATH_INFO': '/profile/gabrielaware/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....jango.template.base.Template object at 0x7fe5f433efe0>, <django.template.base.Template object at 0x7fe5f433c610>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fe5f53af520>, {'templates': [<django.template.base.Template...          )'], 'context_line': '        raise NoReverseMatch(msg)', 'post_context': [], 'pre_context_lineno': 691}}]]})
signal_uid = 'template-render-140625624135040'
exception_uid = 'request-exception-140625624135040'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f4384460>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gabrielaware/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fe5f4387130>
request = <WSGIRequest: GET '/profile/gabrielaware/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
                response = wrapped_callback(request, *callback_args, **callback_kwargs)
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)
                if response is None:
                    raise
    
        # Complain if the view returned None (a common error).
        self.check_response(response, callback)
    
        # If the response supports deferred rendering, apply template
        # response middleware and then render the response
        if hasattr(response, 'render') and callable(response.render):
            for middleware_method in self._template_response_middleware:
                response = middleware_method(request, response)
                # Complain if the template response middleware returned None (a common error).
                self.check_response(
                    response,
                    middleware_method,
                    name='%s.process_template_response' % (
                        middleware_method.__self__.__class__.__name__,
                    )
                )
            try:
>               response = response.render()

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    def render(self):
        """Render (thereby finalizing) the content of the response.
    
        If the content has already been rendered, this is a no-op.
    
        Return the baked response instance.
        """
        retval = self
        if not self._is_rendered:
>           self.content = self.rendered_content

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    @property
    def rendered_content(self):
        """Return the freshly rendered content for the template and context
        described by the TemplateResponse.
    
        This *does not* set the final content of the response. To set the
        response content, you must either call render(), or set the
        content explicitly using the value of this property.
        """
        template = self.resolve_template(self.template_name)
        context = self.resolve_context(self.context_data)
>       return template.render(context, self._request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.backends.django.Template object at 0x7fe5f44dc6a0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]
request = <WSGIRequest: GET '/profile/gabrielaware/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/backends/django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f436d090>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f436d090>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f433efe0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<django.template.defaulttags.LoadNode object at 0x7fe5f433e260>, <TextNode: '\n'>, <django.template.defaulttags.LoadN...n    </main>'>, <django.template.loader_tags.IncludeNode object at 0x7fe5f433d630>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render(self, context):
        block_context = context.render_context.get(BLOCK_CONTEXT_KEY)
        with context.push():
            if block_context is None:
                context['block'] = self
                result = self.nodelist.render(context)
            else:
                push = block = block_context.pop(self.name)
                if block is None:
                    block = self
                # Create new block so we can store context without thread-safety issues.
                block = type(self)(block.name, block.nodelist)
                block.context = context
                context['block'] = block
>               result = block.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n  <h1 class="mb-5 text-c'>, <Variable Node: profile.username>, <TextNode: '</h1>\n  <small>\n    <ul c'...tail_len: 3>, <TextNode: '\n  '>, <django.template.loader_tags.IncludeNode object at 0x7fe5f433c220>, <TextNode: '\n'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n      <a class="btn btn-'>, <django.template.defaulttags.URLNode object at 0x7fe5f436ecb0>, <TextNode: ... профиль</'>, <django.template.defaulttags.URLNode object at 0x7fe5f433cd00>, <TextNode: '">Изменить пароль</a>\n   '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f436ecb0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f436ecb0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...eep Site Who>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f44fc280>, 'profile': <User: gabrielaware>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

viewname = 'blog:edit_profile', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/i/myProject/django_sprint4/django-sprint4-1/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'edit_profile', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'edit_profile' not found. 'edit_profile' is not a valid view function or pattern name.

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7fe5f455f550>
unpublished_posts_with_published_locations = [<Post: Drive Affect Official Civil Time Page>, <Post: Everyone Prove Generation Minute Win Give>, <Post: Staff Machine Face Keep Site Who>]

    def test_unpublished(self, unpublished_posts_with_published_locations):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7fe5f420d8a0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
__________________ TestContent.test_only_own_pubs_in_profile ___________________

self = <test_content.ProfilePostContentTester object at 0x7fe5f3e895d0>
client = <django.test.client.Client object at 0x7fe5f3d55750>
url = '/profile/tommynicholson/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d55750>
path = '/profile/tommynicholson/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d55750>
path = '/profile/tommynicholson/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d55750>, method = 'GET'
path = '/profile/tommynicholson/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/tommynicholson/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/tommynicholson/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d55750>
request = {'PATH_INFO': '/profile/tommynicholson/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=43keis04lqe0ppcyvlvm7b6q8ccaf0pq', 'PATH_INFO': '/profile/tommynicholson/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....jango.template.base.Template object at 0x7fe5f3e79150>, <django.template.base.Template object at 0x7fe5f3e77ee0>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fe5f53af520>, {'templates': [<django.template.base.Template...          )'], 'context_line': '        raise NoReverseMatch(msg)', 'post_context': [], 'pre_context_lineno': 691}}]]})
signal_uid = 'template-render-140625616197056'
exception_uid = 'request-exception-140625616197056'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d55750>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/tommynicholson/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fe5f3df0610>
request = <WSGIRequest: GET '/profile/tommynicholson/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
                response = wrapped_callback(request, *callback_args, **callback_kwargs)
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)
                if response is None:
                    raise
    
        # Complain if the view returned None (a common error).
        self.check_response(response, callback)
    
        # If the response supports deferred rendering, apply template
        # response middleware and then render the response
        if hasattr(response, 'render') and callable(response.render):
            for middleware_method in self._template_response_middleware:
                response = middleware_method(request, response)
                # Complain if the template response middleware returned None (a common error).
                self.check_response(
                    response,
                    middleware_method,
                    name='%s.process_template_response' % (
                        middleware_method.__self__.__class__.__name__,
                    )
                )
            try:
>               response = response.render()

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    def render(self):
        """Render (thereby finalizing) the content of the response.
    
        If the content has already been rendered, this is a no-op.
    
        Return the baked response instance.
        """
        retval = self
        if not self._is_rendered:
>           self.content = self.rendered_content

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    @property
    def rendered_content(self):
        """Return the freshly rendered content for the template and context
        described by the TemplateResponse.
    
        This *does not* set the final content of the response. To set the
        response content, you must either call render(), or set the
        content explicitly using the value of this property.
        """
        template = self.resolve_template(self.template_name)
        context = self.resolve_context(self.context_data)
>       return template.render(context, self._request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.backends.django.Template object at 0x7fe5f3e89810>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]
request = <WSGIRequest: GET '/profile/tommynicholson/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/backends/django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3e89390>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3e89390>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3e79150>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<django.template.defaulttags.LoadNode object at 0x7fe5f3e749d0>, <TextNode: '\n'>, <django.template.defaulttags.LoadN...n    </main>'>, <django.template.loader_tags.IncludeNode object at 0x7fe5f3e74280>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render(self, context):
        block_context = context.render_context.get(BLOCK_CONTEXT_KEY)
        with context.push():
            if block_context is None:
                context['block'] = self
                result = self.nodelist.render(context)
            else:
                push = block = block_context.pop(self.name)
                if block is None:
                    block = self
                # Create new block so we can store context without thread-safety issues.
                block = type(self)(block.name, block.nodelist)
                block.context = context
                context['block'] = block
>               result = block.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n  <h1 class="mb-5 text-c'>, <Variable Node: profile.username>, <TextNode: '</h1>\n  <small>\n    <ul c'...tail_len: 3>, <TextNode: '\n  '>, <django.template.loader_tags.IncludeNode object at 0x7fe5f3e78f70>, <TextNode: '\n'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n      <a class="btn btn-'>, <django.template.defaulttags.URLNode object at 0x7fe5f3e78370>, <TextNode: ... профиль</'>, <django.template.defaulttags.URLNode object at 0x7fe5f3e78070>, <TextNode: '">Изменить пароль</a>\n   '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f3e78370>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f3e78370>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...meone Land>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e896c0>, 'profile': <User: tommynicholson>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

viewname = 'blog:edit_profile', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/i/myProject/django_sprint4/django-sprint4-1/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'edit_profile', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'edit_profile' not found. 'edit_profile' is not a valid view function or pattern name.

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7fe5f453c2b0>
user_client = <django.test.client.Client object at 0x7fe5f3d55750>
post_with_published_location = <Post: Why Serve Paper Reduce Someone Land>
post_of_another_author = <Post: Want Process Prepare Certain Day Catch>

    def test_only_own_pubs_in_profile(
            self, user_client, post_with_published_location,
            post_of_another_author
    ):
>       response = self.profile_tester.user_client_testget()

tests/test_content.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7fe5f3e895d0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
____________________ TestContent.test_unpublished_category _____________________

self = <test_content.ProfilePostContentTester object at 0x7fe5f3b85de0>
client = <django.test.client.Client object at 0x7fe5f3b863e0>
url = '/profile/tracyconley/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3b863e0>
path = '/profile/tracyconley/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3b863e0>
path = '/profile/tracyconley/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3b863e0>, method = 'GET'
path = '/profile/tracyconley/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/tracyconley/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/tracyconley/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3b863e0>
request = {'PATH_INFO': '/profile/tracyconley/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=pq9s2d6gy9ikmr60lobldho8jldg30as', 'PATH_INFO': '/profile/tracyconley/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....jango.template.base.Template object at 0x7fe5f3b841f0>, <django.template.base.Template object at 0x7fe5f433f0a0>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fe5f53af520>, {'templates': [<django.template.base.Template...          )'], 'context_line': '        raise NoReverseMatch(msg)', 'post_context': [], 'pre_context_lineno': 691}}]]})
signal_uid = 'template-render-140625612754688'
exception_uid = 'request-exception-140625612754688'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3b863e0>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/tracyconley/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fe5f3b86500>
request = <WSGIRequest: GET '/profile/tracyconley/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
                response = wrapped_callback(request, *callback_args, **callback_kwargs)
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)
                if response is None:
                    raise
    
        # Complain if the view returned None (a common error).
        self.check_response(response, callback)
    
        # If the response supports deferred rendering, apply template
        # response middleware and then render the response
        if hasattr(response, 'render') and callable(response.render):
            for middleware_method in self._template_response_middleware:
                response = middleware_method(request, response)
                # Complain if the template response middleware returned None (a common error).
                self.check_response(
                    response,
                    middleware_method,
                    name='%s.process_template_response' % (
                        middleware_method.__self__.__class__.__name__,
                    )
                )
            try:
>               response = response.render()

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    def render(self):
        """Render (thereby finalizing) the content of the response.
    
        If the content has already been rendered, this is a no-op.
    
        Return the baked response instance.
        """
        retval = self
        if not self._is_rendered:
>           self.content = self.rendered_content

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    @property
    def rendered_content(self):
        """Return the freshly rendered content for the template and context
        described by the TemplateResponse.
    
        This *does not* set the final content of the response. To set the
        response content, you must either call render(), or set the
        content explicitly using the value of this property.
        """
        template = self.resolve_template(self.template_name)
        context = self.resolve_context(self.context_data)
>       return template.render(context, self._request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.backends.django.Template object at 0x7fe5f43de0e0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]
request = <WSGIRequest: GET '/profile/tracyconley/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/backends/django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3b844f0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3b844f0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3b841f0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<django.template.defaulttags.LoadNode object at 0x7fe5f433d360>, <TextNode: '\n'>, <django.template.defaulttags.LoadN...n    </main>'>, <django.template.loader_tags.IncludeNode object at 0x7fe5f433f040>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render(self, context):
        block_context = context.render_context.get(BLOCK_CONTEXT_KEY)
        with context.push():
            if block_context is None:
                context['block'] = self
                result = self.nodelist.render(context)
            else:
                push = block = block_context.pop(self.name)
                if block is None:
                    block = self
                # Create new block so we can store context without thread-safety issues.
                block = type(self)(block.name, block.nodelist)
                block.context = context
                context['block'] = block
>               result = block.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n  <h1 class="mb-5 text-c'>, <Variable Node: profile.username>, <TextNode: '</h1>\n  <small>\n    <ul c'...tail_len: 3>, <TextNode: '\n  '>, <django.template.loader_tags.IncludeNode object at 0x7fe5f44dc2e0>, <TextNode: '\n'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n      <a class="btn btn-'>, <django.template.defaulttags.URLNode object at 0x7fe5f44df010>, <TextNode: ... профиль</'>, <django.template.defaulttags.URLNode object at 0x7fe5f44dcca0>, <TextNode: '">Изменить пароль</a>\n   '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f44df010>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f44df010>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...Suddenly Head>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3b84730>, 'profile': <User: tracyconley>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

viewname = 'blog:edit_profile', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/i/myProject/django_sprint4/django-sprint4-1/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'edit_profile', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'edit_profile' not found. 'edit_profile' is not a valid view function or pattern name.

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7fe5f455fbe0>
user_client = <django.test.client.Client object at 0x7fe5f3b863e0>
posts_with_unpublished_category = [<Post: Leg Begin Cell Anything Hold Send>, <Post: Prove Much Hospital Happy Suddenly Head>, <Post: Successful Well Third Morning You Think>]

    def test_unpublished_category(
        self, user_client, posts_with_unpublished_category
    ):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7fe5f3b85de0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
________________________ TestContent.test_future_posts _________________________

self = <test_content.ProfilePostContentTester object at 0x7fe5f3e25c30>
client = <django.test.client.Client object at 0x7fe5f3e262f0>
url = '/profile/levymadison/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3e262f0>
path = '/profile/levymadison/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3e262f0>
path = '/profile/levymadison/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3e262f0>, method = 'GET'
path = '/profile/levymadison/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/levymadison/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/levymadison/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3e262f0>
request = {'PATH_INFO': '/profile/levymadison/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=iesewp0237cd4iybdjxjpkur75b7enrr', 'PATH_INFO': '/profile/levymadison/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....jango.template.base.Template object at 0x7fe5f40e7160>, <django.template.base.Template object at 0x7fe5f40e7580>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fe5f53af520>, {'templates': [<django.template.base.Template...          )'], 'context_line': '        raise NoReverseMatch(msg)', 'post_context': [], 'pre_context_lineno': 691}}]]})
signal_uid = 'template-render-140625611737984'
exception_uid = 'request-exception-140625611737984'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3e262f0>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/levymadison/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fe5f3e26350>
request = <WSGIRequest: GET '/profile/levymadison/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
                response = wrapped_callback(request, *callback_args, **callback_kwargs)
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)
                if response is None:
                    raise
    
        # Complain if the view returned None (a common error).
        self.check_response(response, callback)
    
        # If the response supports deferred rendering, apply template
        # response middleware and then render the response
        if hasattr(response, 'render') and callable(response.render):
            for middleware_method in self._template_response_middleware:
                response = middleware_method(request, response)
                # Complain if the template response middleware returned None (a common error).
                self.check_response(
                    response,
                    middleware_method,
                    name='%s.process_template_response' % (
                        middleware_method.__self__.__class__.__name__,
                    )
                )
            try:
>               response = response.render()

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    def render(self):
        """Render (thereby finalizing) the content of the response.
    
        If the content has already been rendered, this is a no-op.
    
        Return the baked response instance.
        """
        retval = self
        if not self._is_rendered:
>           self.content = self.rendered_content

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    @property
    def rendered_content(self):
        """Return the freshly rendered content for the template and context
        described by the TemplateResponse.
    
        This *does not* set the final content of the response. To set the
        response content, you must either call render(), or set the
        content explicitly using the value of this property.
        """
        template = self.resolve_template(self.template_name)
        context = self.resolve_context(self.context_data)
>       return template.render(context, self._request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.backends.django.Template object at 0x7fe5f3e24850>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]
request = <WSGIRequest: GET '/profile/levymadison/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/backends/django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3e25210>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3e25210>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f40e7160>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<django.template.defaulttags.LoadNode object at 0x7fe5f40e6110>, <TextNode: '\n'>, <django.template.defaulttags.LoadN...n    </main>'>, <django.template.loader_tags.IncludeNode object at 0x7fe5f40e5780>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render(self, context):
        block_context = context.render_context.get(BLOCK_CONTEXT_KEY)
        with context.push():
            if block_context is None:
                context['block'] = self
                result = self.nodelist.render(context)
            else:
                push = block = block_context.pop(self.name)
                if block is None:
                    block = self
                # Create new block so we can store context without thread-safety issues.
                block = type(self)(block.name, block.nodelist)
                block.context = context
                context['block'] = block
>               result = block.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n  <h1 class="mb-5 text-c'>, <Variable Node: profile.username>, <TextNode: '</h1>\n  <small>\n    <ul c'...tail_len: 3>, <TextNode: '\n  '>, <django.template.loader_tags.IncludeNode object at 0x7fe5f40e41f0>, <TextNode: '\n'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n      <a class="btn btn-'>, <django.template.defaulttags.URLNode object at 0x7fe5f40e6a10>, <TextNode: ... профиль</'>, <django.template.defaulttags.URLNode object at 0x7fe5f40e4fd0>, <TextNode: '">Изменить пароль</a>\n   '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f40e6a10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f40e6a10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5... Purpose Drug>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e24970>, 'profile': <User: levymadison>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

viewname = 'blog:edit_profile', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/i/myProject/django_sprint4/django-sprint4-1/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'edit_profile', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'edit_profile' not found. 'edit_profile' is not a valid view function or pattern name.

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7fe5f453cc40>
user_client = <django.test.client.Client object at 0x7fe5f3e262f0>
future_posts = [<Post: Everybody Strong In Turn Purpose Drug>, <Post: Most Different Order Step Low Tonight>, <Post: Dream Pay Wind Conference Network Business>]

    def test_future_posts(self, user_client, future_posts):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:441: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7fe5f3e25c30>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
_________________________ TestContent.test_pagination __________________________

self = <test_content.ProfilePostContentTester object at 0x7fe5f3c8fe50>
client = <django.test.client.Client object at 0x7fe5f3c8f760>
url = '/profile/richardpetersen/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3c8f760>
path = '/profile/richardpetersen/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3c8f760>
path = '/profile/richardpetersen/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3c8f760>, method = 'GET'
path = '/profile/richardpetersen/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/richardpetersen/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/richardpetersen/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3c8f760>
request = {'PATH_INFO': '/profile/richardpetersen/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=h2ux7x0vu3j6y180sv2h7wt8qgn92elx', 'PATH_INFO': '/profile/richardpetersen/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....jango.template.base.Template object at 0x7fe5f3e1aa70>, <django.template.base.Template object at 0x7fe5f3e2ba30>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fe5f53af520>, {'templates': [<django.template.base.Template...          )'], 'context_line': '        raise NoReverseMatch(msg)', 'post_context': [], 'pre_context_lineno': 691}}]]})
signal_uid = 'template-render-140625614563584'
exception_uid = 'request-exception-140625614563584'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3c8f760>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/richardpetersen/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fe5f3c8f7c0>
request = <WSGIRequest: GET '/profile/richardpetersen/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
                response = wrapped_callback(request, *callback_args, **callback_kwargs)
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)
                if response is None:
                    raise
    
        # Complain if the view returned None (a common error).
        self.check_response(response, callback)
    
        # If the response supports deferred rendering, apply template
        # response middleware and then render the response
        if hasattr(response, 'render') and callable(response.render):
            for middleware_method in self._template_response_middleware:
                response = middleware_method(request, response)
                # Complain if the template response middleware returned None (a common error).
                self.check_response(
                    response,
                    middleware_method,
                    name='%s.process_template_response' % (
                        middleware_method.__self__.__class__.__name__,
                    )
                )
            try:
>               response = response.render()

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    def render(self):
        """Render (thereby finalizing) the content of the response.
    
        If the content has already been rendered, this is a no-op.
    
        Return the baked response instance.
        """
        retval = self
        if not self._is_rendered:
>           self.content = self.rendered_content

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    @property
    def rendered_content(self):
        """Return the freshly rendered content for the template and context
        described by the TemplateResponse.
    
        This *does not* set the final content of the response. To set the
        response content, you must either call render(), or set the
        content explicitly using the value of this property.
        """
        template = self.resolve_template(self.template_name)
        context = self.resolve_context(self.context_data)
>       return template.render(context, self._request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.backends.django.Template object at 0x7fe5f3e1a3e0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]
request = <WSGIRequest: GET '/profile/richardpetersen/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/backends/django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3e1bd60>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3e1bd60>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3e1aa70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<django.template.defaulttags.LoadNode object at 0x7fe5f3e285b0>, <TextNode: '\n'>, <django.template.defaulttags.LoadN...n    </main>'>, <django.template.loader_tags.IncludeNode object at 0x7fe5f3e2bc70>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render(self, context):
        block_context = context.render_context.get(BLOCK_CONTEXT_KEY)
        with context.push():
            if block_context is None:
                context['block'] = self
                result = self.nodelist.render(context)
            else:
                push = block = block_context.pop(self.name)
                if block is None:
                    block = self
                # Create new block so we can store context without thread-safety issues.
                block = type(self)(block.name, block.nodelist)
                block.context = context
                context['block'] = block
>               result = block.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n  <h1 class="mb-5 text-c'>, <Variable Node: profile.username>, <TextNode: '</h1>\n  <small>\n    <ul c'...tail_len: 3>, <TextNode: '\n  '>, <django.template.loader_tags.IncludeNode object at 0x7fe5f3e29120>, <TextNode: '\n'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n      <a class="btn btn-'>, <django.template.defaulttags.URLNode object at 0x7fe5f3e184c0>, <TextNode: ... профиль</'>, <django.template.defaulttags.URLNode object at 0x7fe5f3e18310>, <TextNode: '">Изменить пароль</a>\n   '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f3e184c0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f3e184c0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...rd Mother>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3c62380>, 'profile': <User: richardpetersen>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

viewname = 'blog:edit_profile', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/i/myProject/django_sprint4/django-sprint4-1/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'edit_profile', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'edit_profile' not found. 'edit_profile' is not a valid view function or pattern name.

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7fe5f453cc70>
user_client = <django.test.client.Client object at 0x7fe5f3c8f760>
many_posts_with_published_locations = [<Post: Develop Live International About Level Daughter>, <Post: Grow Read Its Company Best Listen>, <Post: Under Scen...hree Ever Day>, <Post: When Individual Sister Baby Artist Phone>, <Post: Meeting What Impact Century Ago Perform>, ...]

    def test_pagination(
        self, user_client, many_posts_with_published_locations
    ):
        posts = many_posts_with_published_locations
    
        assert len(posts) > self.profile_tester.n_per_page
        assert len(posts) > self.main_tester.n_per_page
        assert len(posts) > self.category_tester.n_per_page
    
        for (
            tester,
            response_get_func,
            ordering_err_msg,
            pagination_err_msg,
        ) in (
            (
                self.profile_tester,
                self.profile_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора работает"
                    " пагинация."
                ),
            ),
            (
                self.profile_tester,
                self.profile_tester.another_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора "
                    "пагинация работает в соответствии с заданием ."
                ),
            ),
            (
                self.main_tester,
                self.main_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст главной"
                    " страницы отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на главной странице "
                "пагинация работает в соответствии с заданием .",
            ),
            (
                self.category_tester,
                self.category_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " категории отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на странице категории "
                "пагинация работает в соответствии с заданием .",
            ),
        ):
>           response = response_get_func()

tests/test_content.py:539: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7fe5f3c8fe50>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
________________________ TestContent.test_image_visible ________________________

self = <test_content.ProfilePostContentTester object at 0x7fe5f3d75de0>
client = <django.test.client.Client object at 0x7fe5f3d77730>
url = '/profile/kyle42/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d77730>
path = '/profile/kyle42/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d77730>
path = '/profile/kyle42/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d77730>, method = 'GET'
path = '/profile/kyle42/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/kyle42/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/kyle42/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d77730>
request = {'PATH_INFO': '/profile/kyle42/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=12iprikjfm8kctc2k5w8xg9r0p5axny3', 'PATH_INFO': '/profile/kyle42/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....jango.template.base.Template object at 0x7fe5f3d76440>, <django.template.base.Template object at 0x7fe5f3ebbb20>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fe5f53af520>, {'templates': [<django.template.base.Template...          )'], 'context_line': '        raise NoReverseMatch(msg)', 'post_context': [], 'pre_context_lineno': 691}}]]})
signal_uid = 'template-render-140625614370496'
exception_uid = 'request-exception-140625614370496'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d77730>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kyle42/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fe5f3d75b70>
request = <WSGIRequest: GET '/profile/kyle42/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
                response = wrapped_callback(request, *callback_args, **callback_kwargs)
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)
                if response is None:
                    raise
    
        # Complain if the view returned None (a common error).
        self.check_response(response, callback)
    
        # If the response supports deferred rendering, apply template
        # response middleware and then render the response
        if hasattr(response, 'render') and callable(response.render):
            for middleware_method in self._template_response_middleware:
                response = middleware_method(request, response)
                # Complain if the template response middleware returned None (a common error).
                self.check_response(
                    response,
                    middleware_method,
                    name='%s.process_template_response' % (
                        middleware_method.__self__.__class__.__name__,
                    )
                )
            try:
>               response = response.render()

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    def render(self):
        """Render (thereby finalizing) the content of the response.
    
        If the content has already been rendered, this is a no-op.
    
        Return the baked response instance.
        """
        retval = self
        if not self._is_rendered:
>           self.content = self.rendered_content

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    @property
    def rendered_content(self):
        """Return the freshly rendered content for the template and context
        described by the TemplateResponse.
    
        This *does not* set the final content of the response. To set the
        response content, you must either call render(), or set the
        content explicitly using the value of this property.
        """
        template = self.resolve_template(self.template_name)
        context = self.resolve_context(self.context_data)
>       return template.render(context, self._request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.backends.django.Template object at 0x7fe5f3d75990>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]
request = <WSGIRequest: GET '/profile/kyle42/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/backends/django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3d76e30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3d76e30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3d76440>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<django.template.defaulttags.LoadNode object at 0x7fe5f3e778e0>, <TextNode: '\n'>, <django.template.defaulttags.LoadN...n    </main>'>, <django.template.loader_tags.IncludeNode object at 0x7fe5f3ebbc10>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render(self, context):
        block_context = context.render_context.get(BLOCK_CONTEXT_KEY)
        with context.push():
            if block_context is None:
                context['block'] = self
                result = self.nodelist.render(context)
            else:
                push = block = block_context.pop(self.name)
                if block is None:
                    block = self
                # Create new block so we can store context without thread-safety issues.
                block = type(self)(block.name, block.nodelist)
                block.context = context
                context['block'] = block
>               result = block.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n  <h1 class="mb-5 text-c'>, <Variable Node: profile.username>, <TextNode: '</h1>\n  <small>\n    <ul c'...tail_len: 3>, <TextNode: '\n  '>, <django.template.loader_tags.IncludeNode object at 0x7fe5f3ba4580>, <TextNode: '\n'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n      <a class="btn btn-'>, <django.template.defaulttags.URLNode object at 0x7fe5f3ba5c30>, <TextNode: ... профиль</'>, <django.template.defaulttags.URLNode object at 0x7fe5f3ba5390>, <TextNode: '">Изменить пароль</a>\n   '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f3ba5c30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f3ba5c30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...ddle Third Country>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3d767a0>, 'profile': <User: kyle42>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

viewname = 'blog:edit_profile', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/i/myProject/django_sprint4/django-sprint4-1/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'edit_profile', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'edit_profile' not found. 'edit_profile' is not a valid view function or pattern name.

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x7fe5f453d210>
user_client = <django.test.client.Client object at 0x7fe5f3d77730>
post_with_published_location = <Post: Picture Environmental Add Middle Third Country>

    def test_image_visible(self, user_client, post_with_published_location):
        post = post_with_published_location
        post_adapter = PostModelAdapter(post)
    
        testers: List[PostContentTester] = [
            self.profile_tester,
            self.main_tester,
            self.category_tester,
        ]
        img_n_with_post_img = {}
    
        for i, tester in enumerate(testers):
            img_soup_with_post_img = BeautifulSoup(
>               tester.user_client_testget().content.decode("utf-8"),
                features="html.parser",
                parse_only=SoupStrainer("img"),
            )

tests/test_content.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x7fe5f3d75de0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
_________________________________ test_profile _________________________________

user = <User: duncanherbert>, another_user = <User: spencerfrancisco>
user_client = <django.test.client.Client object at 0x7fe5f3c057e0>
another_user_client = <django.test.client.Client object at 0x7fe5f3c04f10>
unlogged_client = <django.test.client.Client object at 0x7fe5f3b61a20>

    @pytest.mark.django_db
    def test_profile(
            user, another_user, user_client, another_user_client, unlogged_client
    ):
        user_url = f"/profile/{user.username}/"
        printed_url = "/profile/<username>/"
    
        User = get_user_model()
        status_code_not_404_err_msg = (
            "Убедитесь, что при обращении к странице несуществующего "
            "пользователя возвращается статус 404."
        )
        try:
            response = user_client.get("/profile/this_is_unexisting_user_name/")
        except User.DoesNotExist:
            raise AssertionError(status_code_not_404_err_msg)
    
        assert response.status_code == HTTPStatus.NOT_FOUND, (
            status_code_not_404_err_msg)
    
>       user_response: HttpResponse = user_client.get(user_url)

tests/test_users.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:719: in request
    self.check_exception(response)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:580: in check_exception
    raise exc_value
../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: in inner
    response = get_response(request)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: in _get_response
    response = response.render()
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:105: in render
    self.content = self.rendered_content
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:83: in rendered_content
    return template.render(context, self._request)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/backends/django.py:61: in render
    return self.template.render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:170: in render
    return self._render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: in render
    return compiled_parent._render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:62: in render
    result = block.nodelist.render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: in render
    return nodelist.render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: in render
    bit = node.render_annotated(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: in render_annotated
    return self.render(context)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/base.py:86: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/i/myProject/django_sprint4/django-sprint4-1/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'edit_profile', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'edit_profile' not found. 'edit_profile' is not a valid view function or pattern name.

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch
_________________________________ test_comment _________________________________

user_client = <django.test.client.Client object at 0x7fe5f3e19e70>
another_user_client = <django.test.client.Client object at 0x7fe5f3e1ac80>
unlogged_client = <django.test.client.Client object at 0x7fe5f3e18790>
post_with_published_location = <Post: Ahead Senior Sense Determine Choose Shoulder>
another_user = <User: kurtstewart>
post_comment_context_form_item = KeyVal(key='form', val=<CreateCommentForm bound=False, valid=False, fields=(text)>)
CommentModel = <class 'blog.models.Comment'>
CommentModelAdapter = <class 'adapters.comment.CommentModelAdapter.<locals>._CommentModelAdapter'>
profile_content_tester = <test_content.ProfilePostContentTester object at 0x7fe5f3d154e0>

    @pytest.mark.django_db(transaction=True)
    def test_comment(
            user_client: django.test.Client,
            another_user_client: django.test.Client,
            unlogged_client: django.test.Client,
            post_with_published_location: Any,
            another_user: Model,
            post_comment_context_form_item: Tuple[str, BaseForm],
            CommentModel: Type[Model],
            CommentModelAdapter: CommentModelAdapterT,
            profile_content_tester: ProfilePostContentTester
    ):
        post_with_published_location.author = another_user
        post_with_published_location.save()
        _, ctx_form = post_comment_context_form_item
        a_post_get_response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )
    
        # create comments
        creation_tester = CreateCommentFormTester(
            a_post_get_response,
            CommentModel,
            user_client,
            another_user_client,
            unlogged_client,
            item_adapter=None,
            ModelAdapter=CommentModelAdapter,
        )
    
        Form: Type[BaseForm] = type(ctx_form)
        forms_to_create = create_comment_creation_forms(
            creation_tester, Form, CommentModel, CommentModelAdapter)
    
        response_on_created, created_items = creation_tester.test_create_several(
            forms_to_create[1:], qs=CommentModel.objects.all()
        )
        content = response_on_created.content.decode(encoding="utf8")
        creation_tester.test_creation_response(content, created_items)
    
        comment_count_repr = f"({len(created_items)})"
    
        index_content = user_client.get("/").content.decode("utf-8")
        if comment_count_repr not in index_content:
            raise AssertionError(
                "Убедитесь, что на главной странице под постами отображается"
                " количество комментариев. Число комментариев должно быть указано"
                " в круглых скобках."
            )
    
        # check comment count on profile page
        comment_adapter = CommentModelAdapter(created_items[0])
        comment_post_adapter = PostModelAdapter(comment_adapter.post)
        author_profile_url = f'/profile/{comment_post_adapter.author.username}/'
        profile_content = (
            profile_content_tester.user_client_testget(
                url=author_profile_url).content.decode("utf-8"))
        if comment_count_repr not in profile_content:
            raise AssertionError(
                "Убедитесь, что на странице пользователя под постами отображается"
                " количество комментариев. Число комментариев должно быть указано"
                " в круглых скобках."
            )
    
        created_item_adapters = [CommentModelAdapter(i) for i in created_items]
    
        # edit comments
        post_url = f"/posts/{post_with_published_location.id}/"
        edit_url, del_url = find_edit_and_delete_urls(
            created_item_adapters,
            response_on_created,
            urls_start_with=KeyVal(
                key=post_url.replace(
                    f"/{post_with_published_location.id}/", "/<post_id>/"
                ),
                val=post_url,
            ),
            user_client=user_client,
        )
    
        item_to_edit = created_items[0]
        item_to_edit_adapter = CommentModelAdapter(item_to_edit)
        old_prop_value = item_to_edit_adapter.displayed_field_name_or_value
        update_props = {
            item_to_edit_adapter.item_cls_adapter.displayed_field_name_or_value: (
                f"{old_prop_value} edited"
            )
        }
        delete_url_addr = del_url.key
    
        _test_edit(
            edit_url,
            CommentModelAdapter,
            item_to_edit,
            EditFormTester=EditCommentFormTester,
            user_client=user_client,
            another_user_client=another_user_client,
            unlogged_client=unlogged_client,
            **update_props,
        )
    
        item_to_delete_adapter = item_to_edit_adapter
        DeleteCommentTester(
            item_to_delete_adapter.item_cls,
            user_client,
            another_user_client,
            unlogged_client,
            item_adapter=item_to_delete_adapter,
        ).test_delete_item(
            qs=item_to_delete_adapter.item_cls.objects.all(),
            delete_url_addr=delete_url_addr,
            only_base_form=True,
        )
    
        status_404_on_edit_deleted_comment_err_msg = (
            "Убедитесь, что при обращении к странице редактирования"
            " несуществующего комментария возвращается статус 404."
        )
        try:
>           response = user_client.get(edit_url[0])

tests/test_comment.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3e19e70>
path = '/posts/2/edit_comment/2/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3e19e70>
path = '/posts/2/edit_comment/2/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3e19e70>, method = 'GET'
path = '/posts/2/edit_comment/2/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/posts/2/edit_comment/2/', params='', query='', fragment='')
r = {'PATH_INFO': '/posts/2/edit_comment/2/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3e19e70>
request = {'PATH_INFO': '/posts/2/edit_comment/2/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'CSRF_COOKIE': 'kVf4c5wiCjSD1eZsqkfzojsweML94csha3DR3jPvFe4UCm45tviC28S1z2jAZqpW', 'HTTP_COOKIE': 'csrftoken=kVf4c5wi...2jAZqpW; sessionid=pttihh14psjfrawi20yr6vjzvfap9pah', 'PATH_INFO': '/posts/2/edit_comment/2/', 'QUERY_STRING': '', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....>, <django.template.base.Template object at 0x7fe5f3ea3880>, <django.template.base.Template object at 0x7fe5f3d9b580>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fe5f53af520>, {'templates': [<django.template.base.Template...than one %s -- it returned %s!' % (", '                self.model._meta.object_name,'], 'pre_context_lineno': 428}}]]})
signal_uid = 'template-render-140625611016896'
exception_uid = 'request-exception-140625611016896'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3e19e70>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/edit_comment/2/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fe5f3e1abf0>
request = <WSGIRequest: GET '/posts/2/edit_comment/2/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/edit_comment/2/'>, args = ()
kwargs = {'comment_pk': 2, 'pk': 2}
self = <blog.views.CommentUpdateView object at 0x7fe5f3d9b4c0>

    def view(request, *args, **kwargs):
        self = cls(**initkwargs)
        self.setup(request, *args, **kwargs)
        if not hasattr(self, 'request'):
            raise AttributeError(
                "%s instance has no 'request' attribute. Did you override "
                "setup() and forget to call super()?" % cls.__name__
            )
>       return self.dispatch(request, *args, **kwargs)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/views/generic/base.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <blog.views.CommentUpdateView object at 0x7fe5f3d9b4c0>
request = <WSGIRequest: GET '/posts/2/edit_comment/2/'>, args = ()
kwargs = {'comment_pk': 2, 'pk': 2}

    def dispatch(self, request, *args, **kwargs):
        if (
            self.request.user
>           != Comment.objects.get(pk=self.kwargs["comment_pk"]).author
        ):

blogicum/blog/views.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.models.manager.Manager object at 0x7fe5f3b61d20>, args = ()
kwargs = {'pk': 2}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/db/models/manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <QuerySet [<Comment: Test create comment 1601372 text>, <Comment: Test create comment 1601373 text>, <Comment: Test create comment 1601374 text>]>
args = (), kwargs = {'pk': 2}, clone = <QuerySet []>, limit = 21, num = 0

    def get(self, *args, **kwargs):
        """
        Perform the query and return a single object matching the given
        keyword arguments.
        """
        if self.query.combinator and (args or kwargs):
            raise NotSupportedError(
                'Calling QuerySet.get(...) with filters after %s() is not '
                'supported.' % self.query.combinator
            )
        clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)
        if self.query.can_filter() and not self.query.distinct_fields:
            clone = clone.order_by()
        limit = None
        if not clone.query.select_for_update or connections[clone.db].features.supports_select_for_update_with_limit:
            limit = MAX_GET_RESULTS
            clone.query.set_limits(high=limit)
        num = len(clone)
        if num == 1:
            return clone._result_cache[0]
        if not num:
>           raise self.model.DoesNotExist(
                "%s matching query does not exist." %
                self.model._meta.object_name
            )
E           blog.models.Comment.DoesNotExist: Comment matching query does not exist.

../django-sprint4-2/venv/lib/python3.10/site-packages/django/db/models/query.py:435: DoesNotExist

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x7fe5f3e19e70>
another_user_client = <django.test.client.Client object at 0x7fe5f3e1ac80>
unlogged_client = <django.test.client.Client object at 0x7fe5f3e18790>
post_with_published_location = <Post: Ahead Senior Sense Determine Choose Shoulder>
another_user = <User: kurtstewart>
post_comment_context_form_item = KeyVal(key='form', val=<CreateCommentForm bound=False, valid=False, fields=(text)>)
CommentModel = <class 'blog.models.Comment'>
CommentModelAdapter = <class 'adapters.comment.CommentModelAdapter.<locals>._CommentModelAdapter'>
profile_content_tester = <test_content.ProfilePostContentTester object at 0x7fe5f3d154e0>

    @pytest.mark.django_db(transaction=True)
    def test_comment(
            user_client: django.test.Client,
            another_user_client: django.test.Client,
            unlogged_client: django.test.Client,
            post_with_published_location: Any,
            another_user: Model,
            post_comment_context_form_item: Tuple[str, BaseForm],
            CommentModel: Type[Model],
            CommentModelAdapter: CommentModelAdapterT,
            profile_content_tester: ProfilePostContentTester
    ):
        post_with_published_location.author = another_user
        post_with_published_location.save()
        _, ctx_form = post_comment_context_form_item
        a_post_get_response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )
    
        # create comments
        creation_tester = CreateCommentFormTester(
            a_post_get_response,
            CommentModel,
            user_client,
            another_user_client,
            unlogged_client,
            item_adapter=None,
            ModelAdapter=CommentModelAdapter,
        )
    
        Form: Type[BaseForm] = type(ctx_form)
        forms_to_create = create_comment_creation_forms(
            creation_tester, Form, CommentModel, CommentModelAdapter)
    
        response_on_created, created_items = creation_tester.test_create_several(
            forms_to_create[1:], qs=CommentModel.objects.all()
        )
        content = response_on_created.content.decode(encoding="utf8")
        creation_tester.test_creation_response(content, created_items)
    
        comment_count_repr = f"({len(created_items)})"
    
        index_content = user_client.get("/").content.decode("utf-8")
        if comment_count_repr not in index_content:
            raise AssertionError(
                "Убедитесь, что на главной странице под постами отображается"
                " количество комментариев. Число комментариев должно быть указано"
                " в круглых скобках."
            )
    
        # check comment count on profile page
        comment_adapter = CommentModelAdapter(created_items[0])
        comment_post_adapter = PostModelAdapter(comment_adapter.post)
        author_profile_url = f'/profile/{comment_post_adapter.author.username}/'
        profile_content = (
            profile_content_tester.user_client_testget(
                url=author_profile_url).content.decode("utf-8"))
        if comment_count_repr not in profile_content:
            raise AssertionError(
                "Убедитесь, что на странице пользователя под постами отображается"
                " количество комментариев. Число комментариев должно быть указано"
                " в круглых скобках."
            )
    
        created_item_adapters = [CommentModelAdapter(i) for i in created_items]
    
        # edit comments
        post_url = f"/posts/{post_with_published_location.id}/"
        edit_url, del_url = find_edit_and_delete_urls(
            created_item_adapters,
            response_on_created,
            urls_start_with=KeyVal(
                key=post_url.replace(
                    f"/{post_with_published_location.id}/", "/<post_id>/"
                ),
                val=post_url,
            ),
            user_client=user_client,
        )
    
        item_to_edit = created_items[0]
        item_to_edit_adapter = CommentModelAdapter(item_to_edit)
        old_prop_value = item_to_edit_adapter.displayed_field_name_or_value
        update_props = {
            item_to_edit_adapter.item_cls_adapter.displayed_field_name_or_value: (
                f"{old_prop_value} edited"
            )
        }
        delete_url_addr = del_url.key
    
        _test_edit(
            edit_url,
            CommentModelAdapter,
            item_to_edit,
            EditFormTester=EditCommentFormTester,
            user_client=user_client,
            another_user_client=another_user_client,
            unlogged_client=unlogged_client,
            **update_props,
        )
    
        item_to_delete_adapter = item_to_edit_adapter
        DeleteCommentTester(
            item_to_delete_adapter.item_cls,
            user_client,
            another_user_client,
            unlogged_client,
            item_adapter=item_to_delete_adapter,
        ).test_delete_item(
            qs=item_to_delete_adapter.item_cls.objects.all(),
            delete_url_addr=delete_url_addr,
            only_base_form=True,
        )
    
        status_404_on_edit_deleted_comment_err_msg = (
            "Убедитесь, что при обращении к странице редактирования"
            " несуществующего комментария возвращается статус 404."
        )
        try:
            response = user_client.get(edit_url[0])
        except CommentModel.DoesNotExist:
>           raise AssertionError(
                status_404_on_edit_deleted_comment_err_msg
            )
E           AssertionError: Убедитесь, что при обращении к странице редактирования несуществующего комментария возвращается статус 404.

tests/test_comment.py:253: AssertionError
__________________________________ test_post ___________________________________

self = <form.post.create_form_tester.CreatePostFormTester object at 0x7fe5f3e82da0>
form = <CreatePostForm bound=True, valid=True, fields=(title;image;text;pub_date;location;category;is_published)>
qs = <QuerySet [<Post: Test create post 1789303 title>, <Post: Generation Of Around Voice Region Check>]>
submitter = <form.base_form_tester.AuthorisedSubmitTester object at 0x7fe5f3dc3bf0>
assert_created = True

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        if not form.is_valid():
            raise FormValidationException(form.errors)
        elif form.errors:
            raise FormValidationException(form.errors)
    
        items_before = set(qs.all())
    
        restored_data = restore_cleaned_data(form.cleaned_data)
        try:
>           response = submitter.test_submit(
                url=self._action, data=restored_data
            )

tests/form/base_form_tester.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <form.base_form_tester.AuthorisedSubmitTester object at 0x7fe5f3dc3bf0>
url = '/posts/create/'
data = {'category': 5, 'image': <SimpleUploadedFile: test_image.jpg (image/jpeg)>, 'is_published': False, 'location': 5, ...}

    def test_submit(self, url: str, data: dict) -> HttpResponse:
        assert isinstance(self.client, django.test.Client)
>       response = self.client.post(url, data=data, follow=True)

tests/form/base_form_tester.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d0a3b0>
path = '/posts/create/'
data = {'category': 5, 'image': <SimpleUploadedFile: test_image.jpg (image/jpeg)>, 'is_published': False, 'location': 5, ...}
content_type = 'multipart/form-data; boundary=BoUnDaRyStRiNg', follow = True
secure = False, extra = {}
response = <HttpResponseRedirect status_code=302, "text/html; charset=utf-8", url="/profile/ellenespinoza/">

    def post(self, path, data=None, content_type=MULTIPART_CONTENT,
             follow=False, secure=False, **extra):
        """Request a response from the server using POST."""
        self.extra = extra
        response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
        if follow:
>           response = self._handle_redirects(response, data=data, content_type=content_type, **extra)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d0a3b0>
response = <HttpResponseRedirect status_code=302, "text/html; charset=utf-8", url="/profile/ellenespinoza/">
data = <QueryDict: {}>, content_type = None, extra = {}
redirect_status_codes = (<HTTPStatus.MOVED_PERMANENTLY: 301>, <HTTPStatus.FOUND: 302>, <HTTPStatus.SEE_OTHER: 303>, <HTTPStatus.TEMPORARY_REDIRECT: 307>, <HTTPStatus.PERMANENT_REDIRECT: 308>)
response_url = '/profile/ellenespinoza/'
redirect_chain = [('/profile/ellenespinoza/', 302)]
url = SplitResult(scheme='', netloc='', path='/profile/ellenespinoza/', query='', fragment='')
path = '/profile/ellenespinoza/'
request_method = <bound method Client.get of <django.test.client.Client object at 0x7fe5f3d0a3b0>>

    def _handle_redirects(self, response, data='', content_type='', **extra):
        """
        Follow any redirects by requesting responses from the server using GET.
        """
        response.redirect_chain = []
        redirect_status_codes = (
            HTTPStatus.MOVED_PERMANENTLY,
            HTTPStatus.FOUND,
            HTTPStatus.SEE_OTHER,
            HTTPStatus.TEMPORARY_REDIRECT,
            HTTPStatus.PERMANENT_REDIRECT,
        )
        while response.status_code in redirect_status_codes:
            response_url = response.url
            redirect_chain = response.redirect_chain
            redirect_chain.append((response_url, response.status_code))
    
            url = urlsplit(response_url)
            if url.scheme:
                extra['wsgi.url_scheme'] = url.scheme
            if url.hostname:
                extra['SERVER_NAME'] = url.hostname
            if url.port:
                extra['SERVER_PORT'] = str(url.port)
    
            # Prepend the request path to handle relative path redirects
            path = url.path
            if not path.startswith('/'):
                path = urljoin(response.request['PATH_INFO'], path)
    
            if response.status_code in (HTTPStatus.TEMPORARY_REDIRECT, HTTPStatus.PERMANENT_REDIRECT):
                # Preserve request method and query string (if needed)
                # post-redirect for 307/308 responses.
                request_method = response.request['REQUEST_METHOD'].lower()
                if request_method not in ('get', 'head'):
                    extra['QUERY_STRING'] = url.query
                request_method = getattr(self, request_method)
            else:
                request_method = self.get
                data = QueryDict(url.query)
                content_type = None
    
>           response = request_method(path, data=data, content_type=content_type, follow=False, **extra)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:850: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d0a3b0>
path = '/profile/ellenespinoza/', data = <QueryDict: {}>, follow = False
secure = False, extra = {'content_type': None}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d0a3b0>
path = '/profile/ellenespinoza/', data = <QueryDict: {}>, secure = False
extra = {'content_type': None}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d0a3b0>, method = 'GET'
path = '/profile/ellenespinoza/', data = b'', content_type = None
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/ellenespinoza/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/ellenespinoza/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d0a3b0>
request = {'PATH_INFO': '/profile/ellenespinoza/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'CSRF_COOKIE': 'udYyWL3waa8TzzoCNgkdxYfrN3qREzO6iTF21otp98xzK9jfQ4CxrsOHP8RyfElO', 'HTTP_COOKIE': 'csrftoken=udYyWL3w...P8RyfElO; sessionid=6nbkd2kx6jqxzmdb5bbjayb98ws732gr', 'PATH_INFO': '/profile/ellenespinoza/', 'QUERY_STRING': '', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....jango.template.base.Template object at 0x7fe5f3bf9cf0>, <django.template.base.Template object at 0x7fe5f3dcd7e0>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x7fe5f53af520>, {'templates': [<django.template.base.Template...          )'], 'context_line': '        raise NoReverseMatch(msg)', 'post_context': [], 'pre_context_lineno': 691}}]]})
signal_uid = 'template-render-140625621065024'
exception_uid = 'request-exception-140625621065024'
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x7fe5f3d0a3b0>
response = <HttpResponse status_code=500, "text/html; charset=utf-8">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/ellenespinoza/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fe5f3d09e40>
request = <WSGIRequest: GET '/profile/ellenespinoza/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
                response = wrapped_callback(request, *callback_args, **callback_kwargs)
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)
                if response is None:
                    raise
    
        # Complain if the view returned None (a common error).
        self.check_response(response, callback)
    
        # If the response supports deferred rendering, apply template
        # response middleware and then render the response
        if hasattr(response, 'render') and callable(response.render):
            for middleware_method in self._template_response_middleware:
                response = middleware_method(request, response)
                # Complain if the template response middleware returned None (a common error).
                self.check_response(
                    response,
                    middleware_method,
                    name='%s.process_template_response' % (
                        middleware_method.__self__.__class__.__name__,
                    )
                )
            try:
>               response = response.render()

../django-sprint4-2/venv/lib/python3.10/site-packages/django/core/handlers/base.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    def render(self):
        """Render (thereby finalizing) the content of the response.
    
        If the content has already been rendered, this is a no-op.
    
        Return the baked response instance.
        """
        retval = self
        if not self._is_rendered:
>           self.content = self.rendered_content

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TemplateResponse status_code=200, "text/html; charset=utf-8">

    @property
    def rendered_content(self):
        """Return the freshly rendered content for the template and context
        described by the TemplateResponse.
    
        This *does not* set the final content of the response. To set the
        response content, you must either call render(), or set the
        content explicitly using the value of this property.
        """
        template = self.resolve_template(self.template_name)
        context = self.resolve_context(self.context_data)
>       return template.render(context, self._request)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/response.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.backends.django.Template object at 0x7fe5f3a420b0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]
request = <WSGIRequest: GET '/profile/ellenespinoza/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/backends/django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3e74730>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3e74730>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x7fe5f3bf9cf0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<django.template.defaulttags.LoadNode object at 0x7fe5f3dcd480>, <TextNode: '\n'>, <django.template.defaulttags.LoadN...n    </main>'>, <django.template.loader_tags.IncludeNode object at 0x7fe5f3dcce50>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Block Node: content. Contents: []>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render(self, context):
        block_context = context.render_context.get(BLOCK_CONTEXT_KEY)
        with context.push():
            if block_context is None:
                context['block'] = self
                result = self.nodelist.render(context)
            else:
                push = block = block_context.pop(self.name)
                if block is None:
                    block = self
                # Create new block so we can store context without thread-safety issues.
                block = type(self)(block.name, block.nodelist)
                block.context = context
                context['block'] = block
>               result = block.nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/loader_tags.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n  <h1 class="mb-5 text-c'>, <Variable Node: profile.username>, <TextNode: '</h1>\n  <small>\n    <ul c'...tail_len: 3>, <TextNode: '\n  '>, <django.template.loader_tags.IncludeNode object at 0x7fe5f3c59fc0>, <TextNode: '\n'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<TextNode: '\n      <a class="btn btn-'>, <django.template.defaulttags.URLNode object at 0x7fe5f3c5ab00>, <TextNode: ... профиль</'>, <django.template.defaulttags.URLNode object at 0x7fe5f3c5a080>, <TextNode: '">Изменить пароль</a>\n   '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f3c5ab00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.defaulttags.URLNode object at 0x7fe5f3c5ab00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'paginator': <django.core.paginator.Paginator object at 0x7fe5...egion Check>]>, 'view': <blog.views.AuthorProfileListView object at 0x7fe5f3e74640>, 'profile': <User: ellenespinoza>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/template/defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

viewname = 'blog:edit_profile', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <module 'blog.urls' from '/home/i/myProject/django_sprint4/django-sprint4-1/blogicum/blog/urls.py'> (blog:blog) ''>
lookup_view = 'edit_profile', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'edit_profile' not found. 'edit_profile' is not a valid view function or pattern name.

../django-sprint4-2/venv/lib/python3.10/site-packages/django/urls/resolvers.py:698: NoReverseMatch

The above exception was the direct cause of the following exception:

self = <form.post.create_form_tester.CreatePostFormTester object at 0x7fe5f3e82da0>
form = <CreatePostForm bound=True, valid=True, fields=(title;image;text;pub_date;location;category;is_published)>
qs = <QuerySet [<Post: Test create post 1789303 title>, <Post: Generation Of Around Voice Region Check>]>
submitter = <form.base_form_tester.AuthorisedSubmitTester object at 0x7fe5f3dc3bf0>
assert_created = True

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        try:
>           return super().try_create_item(form, qs, submitter, assert_created)

tests/form/post/create_form_tester.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <form.post.create_form_tester.CreatePostFormTester object at 0x7fe5f3e82da0>
form = <CreatePostForm bound=True, valid=True, fields=(title;image;text;pub_date;location;category;is_published)>
qs = <QuerySet [<Post: Test create post 1789303 title>, <Post: Generation Of Around Voice Region Check>]>
submitter = <form.base_form_tester.AuthorisedSubmitTester object at 0x7fe5f3dc3bf0>
assert_created = True

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        if not form.is_valid():
            raise FormValidationException(form.errors)
        elif form.errors:
            raise FormValidationException(form.errors)
    
        items_before = set(qs.all())
    
        restored_data = restore_cleaned_data(form.cleaned_data)
        try:
            response = submitter.test_submit(
                url=self._action, data=restored_data
            )
        except Exception as e:
>           raise FormValidationException(e) from e
E           form.base_form_tester.FormValidationException: Reverse for 'edit_profile' not found. 'edit_profile' is not a valid view function or pattern name.

tests/form/base_form_tester.py:207: FormValidationException

The above exception was the direct cause of the following exception:

published_category = <Category: Surface Our When Enter Population Interest>
published_location = <Location: Mr. Alexis Sherman DVM>
user_client = <django.test.client.Client object at 0x7fe5f3d0a3b0>
another_user_client = <django.test.client.Client object at 0x7fe5f3d0ab90>
unlogged_client = <django.test.client.Client object at 0x7fe5f3d08400>
comment_to_a_post = <Comment: Word industry article should. Especially per third among smile keep social be. Both course become maybe.
Specific environmental join price ten. North organization fine base expert necessary.>
create_post_context_form_item = KeyVal(key='form', val=<CreatePostForm bound=False, valid=False, fields=(title;image;text;pub_date;location;category;is_published)>)
PostModel = <class 'blog.models.Post'>
CommentModelAdapter = <class 'adapters.comment.CommentModelAdapter.<locals>._CommentModelAdapter'>
main_content_tester = <test_content.MainPostContentTester object at 0x7fe5f3e80a00>

    @pytest.mark.django_db(transaction=True)
    def test_post(
            published_category: Model,
            published_location: Model,
            user_client: django.test.Client,
            another_user_client: django.test.Client,
            unlogged_client: django.test.Client,
            comment_to_a_post: Model,
            create_post_context_form_item: Tuple[str, BaseForm],
            PostModel: Type[Model],
            CommentModelAdapter: CommentModelAdapterT,
            main_content_tester: MainPostContentTester
    ):
        _, ctx_form = create_post_context_form_item
    
        create_a_post_get_response = get_create_a_post_get_response_safely(
            user_client
        )
    
>       response_on_created, created_items = _test_create_items(
            PostModel,
            PostModelAdapter,
            another_user_client,
            create_a_post_get_response,
            ctx_form,
            published_category,
            published_location,
            unlogged_client,
            user_client,
        )

tests/test_post.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_post.py:308: in _test_create_items
    response_on_created, created_items = creation_tester.test_create_several(
tests/form/base_form_tester.py:294: in test_create_several
    response, created = self.test_create_item(
tests/form/base_form_tester.py:264: in test_create_item
    response, created = self.try_create_item(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <form.post.create_form_tester.CreatePostFormTester object at 0x7fe5f3e82da0>
form = <CreatePostForm bound=True, valid=True, fields=(title;image;text;pub_date;location;category;is_published)>
qs = <QuerySet [<Post: Test create post 1789303 title>, <Post: Generation Of Around Voice Region Check>]>
submitter = <form.base_form_tester.AuthorisedSubmitTester object at 0x7fe5f3dc3bf0>
assert_created = True

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        try:
            return super().try_create_item(form, qs, submitter, assert_created)
        except FormValidationException as e:
>           raise AssertionError(
                "При создании поста возникает ошибка:\n"
                f"{type(e).__name__}: {e}"
            ) from e
E           AssertionError: При создании поста возникает ошибка:
E           FormValidationException: Reverse for 'edit_profile' not found. 'edit_profile' is not a valid view function or pattern name.

tests/form/post/create_form_tester.py:79: AssertionError
========================= 9 failed, 17 passed in 4.35s =========================
